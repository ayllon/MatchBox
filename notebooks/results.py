import os
import tarfile
import numpy as np
from typing import Tuple, Any, Mapping, Iterable, Union, List

import pandas

notebook_dir = os.path.dirname(__file__)

def load_results(run_ids: Union[List[str], str], basedir: str = os.path.join(notebook_dir, '..', 'results')) -> Tuple[pandas.DataFrame, Mapping]:
    """
    Load a set of results from a tar file. It is expected to contain the output
    generated by /bin/benchmark.py

    Parameters
    ----------
    run_ids : str or list of strings
        Run identifiers, which is the name of the tgz without the extension
    basedir : str
        Directory where the results are stored

    Returns
    -------
    out : pair
        The first one corresponds to the results of Find2, and the second
        is a dictionary where the key corresponds to the parametrization of FindQ
        and the value is the DataFrame with the results.
    """
    if not isinstance(run_ids, list):
        run_ids = [run_ids]

    all_find2 = []
    all_findq = {}
    
    for run_id in run_ids:    
        tar = tarfile.open(os.path.join(basedir, f'{run_id}.tgz'))
        try:
            find2 = pandas.read_csv(tar.extractfile(f'{run_id}/find2.csv'))
            find2.dropna(0, inplace=True, how='any')
            all_find2.append(find2)
        except KeyError:
            pass
        for m in tar.getnames():
            filename = os.path.basename(m)
            if filename.startswith('findg'):
                name = os.path.splitext(filename)[0]
                parts = name.split('_')
                if len(parts) == 4:
                    _, lambd, gamma, grow = parts
                else:
                    _, lambd, gamma = parts
                    grow = 0
                key = (float(lambd), float(gamma), int(grow))
                if key not in all_findq:
                    all_findq[key] = []
                all_findq[key].append(pandas.read_csv(tar.extractfile(f'{m}')))
        
    return pandas.concat(all_find2), {k: pandas.concat(v) for k, v in all_findq.items()}


def compute_stats(data: pandas.DataFrame, filter_by: Tuple[str, Any]):
    """
    From a DataFrame containing the summary of the runs of one of the algorithm,
    compute the mean and standard deviation of the run-time and match-ratio

    Notes
    -----
    Since exact matches may have been lost by the unary search, or the bootstrapping, the ratio is computed over the
    possible values to obtain.

    Parameters
    ----------
    data : DataFrame
        As output from benchmark.py
    filter_by: pair of string/value
        Restrict the computation to a subset of the data (i.e. filter only by alpha = 0.1)

    Returns
    -------
    out : first, second and third quartiles for the time and for the match ratio, and number of items
    """
    max_ind_column = None
    for c in data.columns:
        if c.startswith('max_'):
            max_ind_column = c

    mask = (data[filter_by[0]] == filter_by[1]) & (data['exact'] > 0) & (data['ind'] > 0)
    masked = data[mask]

    match = (masked[max_ind_column] / masked['exact'])
    time_qs = np.quantile(masked['time'], [0.25, 0.75])
    match_qs = np.quantile(match, [0.25, 0.75])
    nind_qs = np.quantile(masked['unique_ind'], [0.25, 0.75])
    precision = (masked['ind']/masked['tests']).mean()
    overhead = (masked['tests'] / masked['unique_ind']).mean()
    return time_qs.tolist() + match_qs.tolist() + nind_qs.tolist() + [precision, overhead, mask.sum()]


def general_stats(find2: pandas.DataFrame, findq: Mapping[Any, pandas.DataFrame], findq_subset: Iterable = None,
                  alpha: float = 0.1):
    """
    Compute the statistics from both find2 and findq results

    Parameters
    ----------
    find2 :
        Find2 results
    findq :
        Set of FindQ results
    findq_subset :
        Use only these keys from the findq dictionary
    alpha :
        Compute statistics for this value of alpha

    Returns
    -------
    out : DataFrame
        A DataFrame with the aggregated information
    """
    if findq_subset is not None:
        findq = dict([(key, findq[key]) for key in findq_subset])

    rows = [['Find2', None, None] + compute_stats(find2, ('bootstrap_alpha', alpha))]

    for (lambd, gamma, grow), v in findq.items():
        rows.append([f'FindQ {grow}', lambd, np.clip(1 - alpha * gamma, 0., 1.)] + compute_stats(v, ('bootstrap_alpha', alpha)))

    return pandas.DataFrame(
        rows, columns=['Method', 'Lambda', 'Gamma', 'Time Q1', 'Time Q3', 'Match Q1', 'Match Q3', 'Card Q1', 'Card Q3', 'Precision', 'Overhead', 'N']
    ).sort_values(['Method', 'Lambda', 'Gamma'])
